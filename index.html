<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3-Layer Network: Concepts → Mechanisms → Outcomes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background-color: #f8f9fa;
      }

      #network {
        width: 100%;
        height: 800px;
        border: 1px solid #ddd;
        background-color: white;
        border-radius: 8px;
      }

      .controls {
        margin-bottom: 20px;
        padding: 15px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .controls label {
        margin-right: 15px;
        font-weight: 500;
      }

      .controls select {
        padding: 5px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
      }

      .controls input[type="file"] {
        padding: 5px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-top: 15px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 3px;
      }

      .node-label {
        font-size: 11px;
        font-weight: bold;
        text-anchor: middle;
        pointer-events: none;
      }

      .edge {
        stroke-opacity: 0.6;
      }

      .tooltip {
        position: absolute;
        text-align: center;
        width: auto;
        height: auto;
        padding: 8px;
        font: 12px sans-serif;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
        opacity: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Psychological Mechanisms Network</h1>
        <p>
          Interactive visualization of concepts, mechanisms, and outcomes
          relationships
        </p>
      </div>

      <div class="controls">
        <h2 id="networkTitle">
          3-Layer Network: Concepts → Mechanisms → Outcomes
        </h2>

        <div class="control-row">
          <label>
            <strong>Upload CSV File:</strong>
            <input type="file" id="csvFile" accept=".csv" />
          </label>
          <span id="fileStatus">No file loaded</span>
          <button
            id="saveSvg"
            style="
              padding: 8px 16px;
              background-color: #3498db;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
            "
          >
            Save as SVG
          </button>
        </div>

        <div class="control-row">
          <label>
            <input type="checkbox" id="showLabels" checked />
            Show node labels
          </label>

          <label>
            <strong>Cheating Group:</strong>
            <select id="groupSelector">
              <option value="All">All Groups Combined</option>
              <option value="non_cheaters">Non-cheaters</option>
              <option value="partial_cheaters">Partial Cheaters</option>
              <option value="full_cheaters">Full Cheaters</option>
            </select>
          </label>

          <label>
            <input
              type="range"
              id="edgeThreshold"
              min="0"
              max="0.8"
              step="0.01"
              value="0.1"
            />
            Edge threshold: <span id="thresholdValue">0.1</span>
          </label>

          <label>
            <input type="checkbox" id="showPositive" checked />
            Positive correlations
          </label>

          <label>
            <input type="checkbox" id="showNegative" checked />
            Negative correlations
          </label>
        </div>

        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background-color: #3498db"></div>
            <span>Self-Determination Theory</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: #e74c3c"></div>
            <span>Cognitive Dissonance Theory</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: #27ae60"></div>
            <span>Self-Efficacy Theory</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: #f39c12"></div>
            <span>Social Norms Theory</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: #9b59b6"></div>
            <span>Perceived Effectiveness</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: #34495e"></div>
            <span>Outcomes</span>
          </div>
        </div>

        <div class="network-stats" id="networkStats">
          Loading network data...
        </div>
      </div>

      <div id="network">
        <div class="loading">Loading visualization...</div>
      </div>
    </div>

    <div class="tooltip"></div>

    <script>
      // Global variables
      let allData = [];
      let currentGroup = "All";
      let simulation = null;

      // Define the exact node structure as specified
      const CONCEPTS = [
        "autonomy",
        "competence",
        "relatedness",
        "self_concept",
        "cognitive_inconsistency",
        "dissonance_arousal",
        "dissonance_reduction",
        "performance_accomplishments",
        "vicarious_experience",
        "verbal_persuasion",
        "emotional_arousal",
        "descriptive_norms",
        "injunctive_norms",
        "social_sanctions",
        "reference_group_identification",
      ];

      const MECHANISMS = [
        "autonomy_need_satisfaction",
        "autonomy_need_frustration",
        "competence_need_satisfaction",
        "competence_need_frustration",
        "relatedness_need_satisfaction",
        "relatedness_need_frustration",
        "cognitive_discomfort",
        "moral_disengagement",
        "perceived_performance_accomplishments",
        "perceived_vicarious_experience",
        "perceived_verbal_persuasion",
        "perceived_emotional_arousal",
        "perceived_descriptive_norms",
        "perceived_injunctive_norms",
        "perceived_group_identification",
        "perceived_social_sanctions",
        "perceived_honesty",
        "perceived_performance_effect",
        "perceived_experience_effect",
      ];

      const OUTCOMES = ["cheating_behavior", "performance", "experience"];

      // Theory classifications
      const theoryGroups = {
        "Self-Determination": {
          concepts: ["autonomy", "competence", "relatedness"],
          mechanisms: [
            "autonomy_need_satisfaction",
            "autonomy_need_frustration",
            "competence_need_satisfaction",
            "competence_need_frustration",
            "relatedness_need_satisfaction",
            "relatedness_need_frustration",
          ],
          color: "#3498db",
        },
        "Cognitive-Dissonance": {
          concepts: [
            "self_concept",
            "cognitive_inconsistency",
            "dissonance_arousal",
            "dissonance_reduction",
          ],
          mechanisms: ["cognitive_discomfort", "moral_disengagement"],
          color: "#e74c3c",
        },
        "Self-Efficacy": {
          concepts: [
            "performance_accomplishments",
            "vicarious_experience",
            "verbal_persuasion",
            "emotional_arousal",
          ],
          mechanisms: [
            "perceived_performance_accomplishments",
            "perceived_vicarious_experience",
            "perceived_verbal_persuasion",
            "perceived_emotional_arousal",
          ],
          color: "#27ae60",
        },
        "Social-Norms": {
          concepts: [
            "descriptive_norms",
            "injunctive_norms",
            "social_sanctions",
            "reference_group_identification",
          ],
          mechanisms: [
            "perceived_descriptive_norms",
            "perceived_injunctive_norms",
            "perceived_group_identification",
            "perceived_social_sanctions",
          ],
          color: "#f39c12",
        },
        "Perceived-Effectiveness": {
          concepts: [],
          mechanisms: [
            "perceived_honesty",
            "perceived_performance_effect",
            "perceived_experience_effect",
          ],
          color: "#9b59b6",
        },
      };

      // Create node-to-theory mapping
      const nodeToTheory = {};
      Object.keys(theoryGroups).forEach((theory) => {
        const group = theoryGroups[theory];
        group.concepts.forEach((concept) => {
          nodeToTheory[concept] = { theory, type: "concept" };
        });
        group.mechanisms.forEach((mechanism) => {
          nodeToTheory[mechanism] = { theory, type: "mechanism" };
        });
      });

      // Color functions
      function getNodeColor(node, type) {
        if (OUTCOMES.includes(node)) return "#34495e";
        const nodeInfo = nodeToTheory[node];
        if (!nodeInfo) return "#95a5a6";
        return theoryGroups[nodeInfo.theory].color;
      }

      function getNodeSize(node, type) {
        if (type === "outcome") return 24; // was 16
        if (type === "concept") return 18; // was 12
        return 15; // mechanism (was 10)
      }

      // CSV parsing function
      function parseCSV(csvText) {
        const lines = csvText.trim().split("\n");
        const headers = lines[0].split(",").map((h) => h.trim());

        return lines
          .slice(1)
          .map((line) => {
            const values = line.split(",");
            const row = {};
            headers.forEach((header, index) => {
              if (header === "partial_correlation") {
                row[header] = parseFloat(values[index]);
              } else {
                row[header] = values[index]?.trim();
              }
            });
            return row;
          })
          .filter((row) => !isNaN(row.partial_correlation));
      }

      // Load data function
      async function loadData(csvText = null) {
  try {
    let csvData;

    if (csvText) {
      // If CSV text is provided directly (from file upload)
      csvData = csvText;
    } else {
      // Try to check for CSV files in folder first
      const csvFiles = [
        "comprehensive_partial_correlations.csv",
      ];
      
      let fileFound = false;
      
      for (const fileName of csvFiles) {
        try {
          csvData = await window.fs.readFile(fileName, { encoding: "utf8" });
          console.log(`✅ Found and loaded: ${fileName}`);
          document.getElementById("fileStatus").textContent = `✅ Auto-loaded: ${fileName}`;
          document.getElementById("fileStatus").style.color = "#27ae60";
          fileFound = true;
          break; // Use the first file found
        } catch (error) {
          console.log(`❌ File not found: ${fileName}`);
          continue; // Try next file
        }
      }
      
      if (!fileFound) {
        // No CSV files found - show upload prompt
        document.getElementById("network").innerHTML = 
          '<div class="no-data" style="padding: 40px; text-align: center; color: #7f8c8d;">' +
          '<h3>📁 No CSV files detected in folder</h3>' +
          '<p>Please upload the csv containing partial correlations:</p>' +
          '<ul style="list-style: none; padding: 0;">' +
          '</div>';
          
        document.getElementById("fileStatus").textContent = "⚠️ No CSV files found - please upload";
        document.getElementById("fileStatus").style.color = "#f39c12";
        return [];
      }
    }

    const data = parseCSV(csvData);
    allData = data;

    if (!csvText) { // Only update status if we auto-loaded (not from upload)
      document.getElementById("fileStatus").textContent = `✅ Loaded ${data.length} edges successfully`;
      document.getElementById("fileStatus").style.color = "#27ae60";
    }

    return filterDataByGroup(currentGroup);
    
  } catch (error) {
    console.error("Error loading data:", error);
    document.getElementById("fileStatus").textContent = 
      "❌ Error loading data. Please check file format.";
    document.getElementById("fileStatus").style.color = "#e74c3c";
    return [];
  }
}


      // Filter data by group
      function filterDataByGroup(group) {
        if (!allData || allData.length === 0) return [];
        return allData.filter((row) => row.group === group);
      }

      // Create network visualization
      async function createNetwork() {
        let edgeData;

        if (allData.length > 0) {
          edgeData = filterDataByGroup(currentGroup);
        } else {
          edgeData = await loadData();
        }

        if (!edgeData.length) {
          document.getElementById("network").innerHTML =
            '<div class="no-data"></div>';
          return;
        }

        // Clear existing SVG
        d3.select("#network").select("svg").remove();

        // Create all nodes from our predefined lists
        const allNodes = [...CONCEPTS, ...MECHANISMS, ...OUTCOMES];
        const nodes = allNodes.map((id) => {
          let type;
          if (OUTCOMES.includes(id)) type = "outcome";
          else if (CONCEPTS.includes(id)) type = "concept";
          else if (MECHANISMS.includes(id)) type = "mechanism";
          else type = "unknown";

          return {
            id,
            type,
            color: getNodeColor(id, type),
            size: getNodeSize(id, type),
          };
        });

        // Set up SVG
        const container = document.getElementById("network");
        const width = container.clientWidth;
        const height = container.clientHeight;

        const svg = d3
          .select("#network")
          .append("svg")
          .attr("width", width)
          .attr("height", height);

        // Add gradient definitions
        const defs = svg.append("defs");

        // Positive correlation gradient
        const positiveGradient = defs
          .append("linearGradient")
          .attr("id", "positive-gradient")
          .attr("gradientUnits", "userSpaceOnUse");
        positiveGradient
          .append("stop")
          .attr("offset", "0%")
          .attr("stop-color", "#27ae60");
        positiveGradient
          .append("stop")
          .attr("offset", "100%")
          .attr("stop-color", "#2ecc71");

        // Negative correlation gradient
        const negativeGradient = defs
          .append("linearGradient")
          .attr("id", "negative-gradient")
          .attr("gradientUnits", "userSpaceOnUse");
        negativeGradient
          .append("stop")
          .attr("offset", "0%")
          .attr("stop-color", "#e74c3c");
        negativeGradient
          .append("stop")
          .attr("offset", "100%")
          .attr("stop-color", "#c0392b");

        // Create tooltip
        const tooltip = d3.select(".tooltip");

        // Position nodes in 3 concentric circles
        const centerX = width / 2;
        const centerY = height / 2;
        const outerRadius = Math.min(width, height) * 0.45; // concepts at edge
        const middleRadius = Math.min(width, height) * 0.3; // mechanisms in middle
        const innerRadius = Math.min(width, height) * 0.1; // outcomes at center

        // Position concepts on outer circle
        const conceptNodes = nodes.filter((d) => d.type === "concept");
        conceptNodes.forEach((d, i) => {
          const angle = (i / conceptNodes.length) * 2 * Math.PI - Math.PI / 2;
          d.x = centerX + Math.cos(angle) * outerRadius;
          d.y = centerY + Math.sin(angle) * outerRadius;
          d.fx = d.x;
          d.fy = d.y;
        });

        // Position mechanisms on middle circle
        const mechanismNodes = nodes.filter((d) => d.type === "mechanism");
        mechanismNodes.forEach((d, i) => {
          const angle = (i / mechanismNodes.length) * 2 * Math.PI - Math.PI / 2;
          d.x = centerX + Math.cos(angle) * middleRadius;
          d.y = centerY + Math.sin(angle) * middleRadius;
          d.fx = d.x;
          d.fy = d.y;
        });

        // Position outcomes on inner circle
        const outcomeNodes = nodes.filter((d) => d.type === "outcome");
        outcomeNodes.forEach((d, i) => {
          const angle = (i / outcomeNodes.length) * 2 * Math.PI - Math.PI / 2;
          d.x = centerX + Math.cos(angle) * innerRadius;
          d.y = centerY + Math.sin(angle) * innerRadius;
          d.fx = d.x;
          d.fy = d.y;
        });

        // Add layer labels
        svg
          .append("text")
          .attr("class", "layer-label")
          .attr("x", centerX)
          .attr("y", centerY - outerRadius - 20);

        svg
          .append("text")
          .attr("class", "layer-label")
          .attr("x", centerX)
          .attr("y", centerY - middleRadius - 20);

        svg
          .append("text")
          .attr("class", "layer-label")
          .attr("x", centerX)
          .attr("y", centerY - innerRadius - 20);

        // Create node lookup
        const nodeMap = {};
        nodes.forEach((n) => (nodeMap[n.id] = n));

        // Update visualization function
        function updateVisualization() {
          const threshold = parseFloat(
            d3.select("#edgeThreshold").property("value")
          );
          const showPositive = d3.select("#showPositive").property("checked");
          const showNegative = d3.select("#showNegative").property("checked");

          let filteredEdges = edgeData.filter((d) => {
            const absCorr = Math.abs(d.partial_correlation);
            const isPositive = d.partial_correlation > 0;
            const meetsThreshold = absCorr >= threshold;
            const typeAllowed =
              (isPositive && showPositive) || (!isPositive && showNegative);

            return (
              meetsThreshold &&
              typeAllowed &&
              nodeMap[d.source] &&
              nodeMap[d.target]
            );
          });

          // Update edges
          const edges = svg
            .selectAll(".edge")
            .data(filteredEdges, (d) => `${d.source}-${d.target}`);

          edges.exit().remove();

          edges
            .enter()
            .append("line")
            .attr("class", "edge")
            .merge(edges)
            .attr("stroke", (d) =>
              d.partial_correlation > 0
                ? "url(#positive-gradient)"
                : "url(#negative-gradient)"
            )
            .attr("stroke-width", (d) =>
              Math.max(1, Math.abs(d.partial_correlation) * 8)
            )
            .attr("stroke-opacity", 0.7)
            .attr("x1", (d) => nodeMap[d.source]?.x || 0)
            .attr("y1", (d) => nodeMap[d.source]?.y || 0)
            .attr("x2", (d) => nodeMap[d.target]?.x || 0)
            .attr("y2", (d) => nodeMap[d.target]?.y || 0)
            .on("mouseover", function (event, d) {
              d3.select(this).attr("stroke-opacity", 1);

              const sourceTheory = nodeToTheory[d.source]?.theory || "Outcome";
              const targetTheory = nodeToTheory[d.target]?.theory || "Outcome";

              tooltip.transition().duration(200).style("opacity", 0.95);
              tooltip
                .html(
                  `
                <strong>Connection:</strong><br/>
                ${d.source.replace(/_/g, " ")} → ${d.target.replace(
                    /_/g,
                    " "
                  )}<br/>
                <strong>Correlation:</strong> ${
                  d.partial_correlation > 0 ? "+" : ""
                }${d.partial_correlation.toFixed(3)}<br/>
                <strong>Source Theory:</strong> ${sourceTheory.replace(
                  "-",
                  " "
                )}<br/>
                <strong>Target Theory:</strong> ${targetTheory.replace(
                  "-",
                  " "
                )}<br/>
                <strong>Edge Type:</strong> ${
                  d.edge_type?.replace(/_/g, " ") || "Unknown"
                }
              `
                )
                .style("left", event.pageX + 10 + "px")
                .style("top", event.pageY - 10 + "px");
            })
            .on("mouseout", function (event, d) {
              d3.select(this).attr("stroke-opacity", 0.7);
              tooltip.transition().duration(300).style("opacity", 0);
            });

          // Update stats
          const totalEdges = edgeData.length;
          const visibleEdges = filteredEdges.length;
          const positiveEdges = filteredEdges.filter(
            (d) => d.partial_correlation > 0
          ).length;
          const negativeEdges = filteredEdges.filter(
            (d) => d.partial_correlation < 0
          ).length;

          document.getElementById("networkStats").innerHTML = `
            <strong>Network Statistics:</strong> 
            Showing ${visibleEdges} of ${totalEdges} edges | 
            Positive: ${positiveEdges} | 
            Negative: ${negativeEdges} | 
            Nodes: ${nodes.length} (${conceptNodes.length} concepts, ${mechanismNodes.length} mechanisms, ${outcomeNodes.length} outcomes)
          `;

          document.getElementById(
            "networkTitle"
          ).textContent = `3-Layer Network: Concepts → Mechanisms → Outcomes (${currentGroup.replace(
            "_",
            " "
          )})`;
        }

        // Draw initial edges
        updateVisualization();

        // Draw nodes
        const nodeElements = svg
          .selectAll(".node")
          .data(nodes)
          .enter()
          .append("circle")
          .attr("class", "node")
          .attr("r", (d) => d.size)
          .attr("fill", (d) => d.color)
          .attr("stroke", "#ffffff")
          .attr("stroke-width", 2)
          .attr("cx", (d) => d.x)
          .attr("cy", (d) => d.y)
          .style("filter", "drop-shadow(2px 2px 4px rgba(0,0,0,0.3))")
          .on("mouseover", function (event, d) {
            d3.select(this)
              .transition()
              .duration(200)
              .attr("r", d.size * 1.5);

            const theory = nodeToTheory[d.id]?.theory || "Outcome";
            const typeDesc = d.type.charAt(0).toUpperCase() + d.type.slice(1);

            tooltip.transition().duration(200).style("opacity", 0.95);
            tooltip
              .html(
                `
              <strong>${d.id.replace(/_/g, " ")}</strong><br/>
              <strong>Type:</strong> ${typeDesc}<br/>
              <strong>Theory:</strong> ${theory.replace("-", " ")}<br/>
              <strong>Layer:</strong> ${
                d.type === "concept"
                  ? "Outer"
                  : d.type === "mechanism"
                  ? "Middle"
                  : "Inner"
              }
            `
              )
              .style("left", event.pageX + 10 + "px")
              .style("top", event.pageY - 10 + "px");
          })
          .on("mouseout", function (event, d) {
            d3.select(this).transition().duration(200).attr("r", d.size);
            tooltip.transition().duration(300).style("opacity", 0);
          });

        // Add labels
        const labels = svg
          .selectAll(".node-label")
          .data(nodes)
          .enter()
          .append("text")
          .attr("class", "node-label")
          .attr("x", (d) => d.x)
          .attr("y", (d) => d.y - d.size - 5)
          .text((d) => d.id.replace(/_/g, " "))
          .style("font-size", (d) => (d.type === "outcome" ? "15px" : "13px"))
          .style("font-weight", (d) => (d.type === "outcome" ? "bold" : "400"));

        // Store update function and labels for external use
        window.updateVisualization = updateVisualization;
        window.currentLabels = labels;
      }

      function saveSvg() {
        const svg = d3.select("#network svg").node();
        if (!svg) {
          alert("No visualization to save!");
          return;
        }

        // Clone the SVG to avoid modifying the original
        const svgClone = svg.cloneNode(true);

        // Set explicit dimensions and add styles (same as before)
        svgClone.setAttribute("width", svg.clientWidth || 800);
        svgClone.setAttribute("height", svg.clientHeight || 600);
        svgClone.setAttribute("xmlns", "http://www.w3.org/2000/svg");

        const style = document.createElement("style");
        style.textContent = `
    .node-label { font-size: 11px; font-weight: bold; text-anchor: middle; pointer-events: none; font-family: Arial, sans-serif; }
    .edge { stroke-opacity: 0.6; }
  `;
        svgClone.insertBefore(style, svgClone.firstChild);

        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(svgClone);

        // Create filename with timestamp
        const timestamp = new Date()
          .toISOString()
          .slice(0, 19)
          .replace(/:/g, "-");
        const filename = `network_${currentGroup}_${timestamp}.svg`;

        try {
          const blob = new Blob([svgString], { type: "image/svg+xml" });
          const url = URL.createObjectURL(blob);

          const link = document.createElement("a");
          link.href = url;
          link.download = filename;
          link.style.display = "none";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          URL.revokeObjectURL(url);

          // More specific success message
          document.getElementById(
            "fileStatus"
          ).textContent = `✅ ${filename} saved to Downloads folder`;
          document.getElementById("fileStatus").style.color = "#27ae60";

          // Also log to console
          console.log(`SVG file saved as: ${filename}`);
        } catch (error) {
          console.error("Save failed:", error);
          alert(
            `Save failed. Check your Downloads folder for: ${filename}\nOr check browser console for errors.`
          );
        }
      }

      // Initialize and set up event handlers
      async function init() {
        // File upload handler
        document
          .getElementById("csvFile")
          .addEventListener("change", async function (event) {
            const file = event.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = async function (e) {
                const csvText = e.target.result;
                await loadData(csvText);
                await createNetwork();
              };
              reader.readAsText(file);
            }
          });
        document.getElementById("saveSvg").addEventListener("click", saveSvg);

        // Group selector handler
        d3.select("#groupSelector").on("change", async function () {
          currentGroup = this.value;
          await createNetwork();
        });

        // Other control handlers
        d3.select("#showLabels").on("change", function () {
          if (window.currentLabels) {
            window.currentLabels.style(
              "display",
              this.checked ? "block" : "none"
            );
          }
        });

        d3.select("#edgeThreshold").on("input", function () {
          d3.select("#thresholdValue").text(this.value);
          if (window.updateVisualization) {
            window.updateVisualization();
          }
        });

        d3.select("#showPositive").on("change", function () {
          if (window.updateVisualization) {
            window.updateVisualization();
          }
        });

        d3.select("#showNegative").on("change", function () {
          if (window.updateVisualization) {
            window.updateVisualization();
          }
        });

        // Initial threshold display
        d3.select("#thresholdValue").text(
          d3.select("#edgeThreshold").property("value")
        );

        // Try to load data initially
        await createNetwork();
      }

      // Handle window resize
      window.addEventListener("resize", function () {
        if (window.updateVisualization) {
          setTimeout(createNetwork, 100);
        }
      });

      // Start the application
      init();
    </script>
  </body>
</html>
