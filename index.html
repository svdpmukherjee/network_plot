<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3-Layer Network: Concepts ‚Üí Mechanisms ‚Üí Outcomes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background-color: #f8f9fa;
      }

      #network {
        width: 100%;
        height: 800px;
        border: 1px solid #ddd;
        background-color: white;
        border-radius: 8px;
      }

      .controls {
        margin-bottom: 20px;
        padding: 15px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .control-row {
        display: flex;
        align-items: center;
        gap: 20px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }

      .controls label {
        margin-right: 15px;
        font-weight: 500;
      }

      .controls select {
        padding: 5px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
      }

      .controls input[type="file"] {
        padding: 5px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-top: 15px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 3px;
      }

      .node-label {
        font-size: 11px;
        font-weight: bold;
        text-anchor: middle;
        pointer-events: none;
      }

      .edge {
        stroke-opacity: 0.6;
      }

      .tooltip {
        position: absolute;
        text-align: center;
        width: auto;
        height: auto;
        padding: 8px;
        font: 12px sans-serif;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
        opacity: 0;
      }

      .no-data {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        flex-direction: column;
        color: #666;
        font-size: 16px;
        text-align: center;
        padding: 20px;
      }

      .file-info {
        margin-top: 10px;
        padding: 10px;
        background-color: #f0f7ff;
        border: 1px solid #b0d4ff;
        border-radius: 4px;
        font-size: 14px;
        color: #1a5490;
      }

      #fileStatus {
        margin-left: 10px;
        font-weight: 500;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Psychological Mechanisms Network</h1>
        <p>
          Interactive visualization of concepts, mechanisms, and outcomes
          relationships
        </p>
      </div>

      <div class="controls">
        <h2 id="networkTitle">
          3-Layer Network: Concepts ‚Üí Mechanisms ‚Üí Outcomes
        </h2>

        <div class="control-row">
          <label>
            <strong>CSV Data:</strong>
            <input type="file" id="csvFile" accept=".csv" style="display: none;" />
            <button id="uploadBtn" style="
              padding: 8px 16px;
              background-color: #27ae60;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              margin-left: 10px;
            ">
              üìÅ Upload CSV File
            </button>
          </label>
          <span id="fileStatus">üîç Looking for CSV files...</span>
          <button
            id="saveSvg"
            style="
              padding: 8px 16px;
              background-color: #3498db;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
            "
          >
            üíæ Save as SVG
          </button>
        </div>

        <div id="fileInfo" class="file-info" style="display: none;">
          <strong>üìã Available CSV files detected:</strong>
          <div id="detectedFiles"></div>
        </div>

        <div class="control-row">
          <label>
            <input type="checkbox" id="showLabels" checked />
            Show node labels
          </label>

          <label>
            <strong>Cheating Group:</strong>
            <select id="groupSelector">
              <option value="All">All Groups Combined</option>
              <option value="non_cheaters">Non-cheaters</option>
              <option value="partial_cheaters">Partial Cheaters</option>
              <option value="full_cheaters">Full Cheaters</option>
            </select>
          </label>

          <label>
            <input
              type="range"
              id="edgeThreshold"
              min="0"
              max="0.8"
              step="0.01"
              value="0.1"
            />
            Edge threshold: <span id="thresholdValue">0.1</span>
          </label>

          <label>
            <input type="checkbox" id="showPositive" checked />
            Positive correlations
          </label>

          <label>
            <input type="checkbox" id="showNegative" checked />
            Negative correlations
          </label>
        </div>

        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background-color: #3498db"></div>
            <span>Self-Determination Theory</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: #e74c3c"></div>
            <span>Cognitive Dissonance Theory</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: #27ae60"></div>
            <span>Self-Efficacy Theory</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: #f39c12"></div>
            <span>Social Norms Theory</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: #9b59b6"></div>
            <span>Moral Disengagement Theory</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: #34495e"></div>
            <span>Outcomes</span>
          </div>
        </div>
      </div>

      <div id="network"></div>
    </div>

    <script>
      // Global variables
      let allData = [];
      let currentGroup = "All";

      // Node definitions
      const CONCEPTS = [
        "autonomy",
        "competence", 
        "relatedness",
        "self_concept",
        "cognitive_inconsistency",
        "dissonance_arousal",
        "dissonance_reduction",
        "performance_accomplishments",
        "vicarious_experience", 
        "verbal_persuasion",
        "emotional_arousal",
        "descriptive_norms",
        "injunctive_norms",
        "social_sanctions",
        "reference_group_identification"
      ];

      const MECHANISMS = [
        "autonomy_need_satisfaction",
        "autonomy_need_frustration",
        "competence_need_satisfaction",
        "competence_need_frustration",
        "relatedness_need_satisfaction",
        "relatedness_need_frustration",
        "overall_need_satisfaction",
        "overall_need_frustration",
        "performance_accomplishments",
        "vicarious_experience",
        "verbal_persuasion", 
        "emotional_arousal",
        "task_specific_self_efficacy",
        "injunctive_norms",
        "descriptive_norms",
        "reference_group_identification",
        "social_sanctions",
        "norm_perception",
        "cognitive_discomfort",
        "moral_disengagement"
      ];

      const OUTCOMES = [
        "cheating_rate_main_round",
        "performance_score_excluding_cheated_words",
        "performance_score_including_cheated_words",
        "task_engagement",
        "task_satisfaction",
        "PME_on_honest_task_completion",
        "PME_on_task_performance",
        "PME_on_task_experience"
      ];

      // Theory mappings
      const nodeToTheory = {};
      const theoryGroups = {
        "Self-Determination": { color: "#3498db" },
        "Cognitive-Dissonance": { color: "#e74c3c" },
        "Self-Efficacy": { color: "#27ae60" },
        "Social-Norms": { color: "#f39c12" },
        "Moral-Disengagement": { color: "#9b59b6" }
      };

      // Self-Determination Theory
      ["autonomy", "competence", "relatedness"].forEach(node => {
        nodeToTheory[node] = { theory: "Self-Determination" };
      });
      ["autonomy_need_satisfaction", "autonomy_need_frustration", 
       "competence_need_satisfaction", "competence_need_frustration",
       "relatedness_need_satisfaction", "relatedness_need_frustration",
       "overall_need_satisfaction", "overall_need_frustration"].forEach(node => {
        nodeToTheory[node] = { theory: "Self-Determination" };
      });

      // Cognitive Dissonance Theory
      ["self_concept", "cognitive_inconsistency", "dissonance_arousal", "dissonance_reduction"].forEach(node => {
        nodeToTheory[node] = { theory: "Cognitive-Dissonance" };
      });
      ["cognitive_discomfort"].forEach(node => {
        nodeToTheory[node] = { theory: "Cognitive-Dissonance" };
      });

      // Self-Efficacy Theory
      ["performance_accomplishments", "vicarious_experience", "verbal_persuasion", "emotional_arousal"].forEach(node => {
        nodeToTheory[node] = { theory: "Self-Efficacy" };
      });
      ["task_specific_self_efficacy"].forEach(node => {
        nodeToTheory[node] = { theory: "Self-Efficacy" };
      });

      // Social Norms Theory
      ["descriptive_norms", "injunctive_norms", "social_sanctions", "reference_group_identification"].forEach(node => {
        nodeToTheory[node] = { theory: "Social-Norms" };
      });
      ["norm_perception"].forEach(node => {
        nodeToTheory[node] = { theory: "Social-Norms" };
      });

      // Moral Disengagement Theory
      ["moral_disengagement"].forEach(node => {
        nodeToTheory[node] = { theory: "Moral-Disengagement" };
      });

      // Color functions
      function getNodeColor(node, type) {
        if (OUTCOMES.includes(node)) return "#34495e";
        const nodeInfo = nodeToTheory[node];
        if (!nodeInfo) return "#95a5a6";
        return theoryGroups[nodeInfo.theory].color;
      }

      function getNodeSize(node, type) {
        if (type === "outcome") return 24;
        if (type === "concept") return 18;
        return 15; // mechanism
      }

      // CSV parsing function
      function parseCSV(csvText) {
        const lines = csvText.trim().split("\n");
        const headers = lines[0].split(",").map((h) => h.trim());

        return lines
          .slice(1)
          .map((line) => {
            const values = line.split(",");
            const row = {};
            headers.forEach((header, index) => {
              if (header === "partial_correlation") {
                row[header] = parseFloat(values[index]);
              } else {
                row[header] = values[index]?.trim();
              }
            });
            return row;
          })
          .filter((row) => !isNaN(row.partial_correlation));
      }

      // Improved CSV file detection and loading
      async function tryLoadLocalFiles() {
        const filesToTry = [
          'comprehensive_partial_correlations.csv',
          'network_edges.csv',
          'final_dataset.csv'
        ];
        
        let detectedFiles = [];
        let loadedData = null;

        for (const filename of filesToTry) {
          try {
            document.getElementById("fileStatus").textContent = `üîç Checking for ${filename}...`;
            
            const csvData = await window.fs.readFile(filename, { encoding: "utf8" });
            detectedFiles.push(filename);
            
            // Try to load the first successfully found file
            if (!loadedData && filename === 'comprehensive_partial_correlations.csv') {
              loadedData = parseCSV(csvData);
              document.getElementById("fileStatus").textContent = `‚úÖ Loaded ${filename} with ${loadedData.length} edges`;
              document.getElementById("fileStatus").style.color = "#27ae60";
            }
          } catch (error) {
            // File not found, continue to next file
            console.log(`${filename} not found:`, error.message);
          }
        }

        // Show detected files info
        if (detectedFiles.length > 0) {
          document.getElementById("fileInfo").style.display = "block";
          document.getElementById("detectedFiles").innerHTML = 
            detectedFiles.map(f => `<div>‚Ä¢ ${f}</div>`).join('');
        }

        return loadedData;
      }

      // Load data function with improved file handling
      async function loadData(csvText = null) {
        try {
          let csvData;
          let data;

          if (csvText) {
            // User uploaded a file
            csvData = csvText;
            data = parseCSV(csvData);
            document.getElementById("fileStatus").textContent = `‚úÖ Loaded uploaded file with ${data.length} edges`;
            document.getElementById("fileStatus").style.color = "#27ae60";
          } else {
            // Try to load from local files
            data = await tryLoadLocalFiles();
            
            if (!data || data.length === 0) {
              // No files found, show upload prompt
              document.getElementById("fileStatus").textContent = "üì§ No CSV files found. Please upload a file.";
              document.getElementById("fileStatus").style.color = "#f39c12";
              document.getElementById("network").innerHTML = `
                <div class="no-data">
                  <h3>üìä Network Visualization Ready</h3>
                  <p>No CSV data files were found in the repository.</p>
                  <p><strong>Please upload one of these files:</strong></p>
                  <ul style="text-align: left; margin: 20px auto; display: inline-block;">
                    <li><code>comprehensive_partial_correlations.csv</code> (recommended)</li>
                    <li><code>network_edges.csv</code></li>
                    <li><code>final_dataset.csv</code></li>
                  </ul>
                  <p>Click the <strong>"üìÅ Upload CSV File"</strong> button above to get started.</p>
                </div>
              `;
              return [];
            }
          }

          allData = data;
          return filterDataByGroup(currentGroup);

        } catch (error) {
          console.error("Error loading data:", error);
          document.getElementById("fileStatus").textContent = "‚ùå Error loading data. Please check file format.";
          document.getElementById("fileStatus").style.color = "#e74c3c";
          return [];
        }
      }

      // Filter data by group
      function filterDataByGroup(group) {
        if (!allData || allData.length === 0) return [];
        if (group === "All") return allData;
        return allData.filter((row) => row.group === group);
      }

      // Create network visualization
      async function createNetwork() {
        let edgeData;

        if (allData.length > 0) {
          edgeData = filterDataByGroup(currentGroup);
        } else {
          edgeData = await loadData();
        }

        if (!edgeData.length) {
          return; // loadData already handled the display
        }

        // Clear existing SVG
        d3.select("#network").select("svg").remove();

        // Create all nodes from our predefined lists
        const allNodes = [...CONCEPTS, ...MECHANISMS, ...OUTCOMES];
        const nodes = allNodes.map((id) => {
          let type;
          if (OUTCOMES.includes(id)) type = "outcome";
          else if (CONCEPTS.includes(id)) type = "concept";
          else if (MECHANISMS.includes(id)) type = "mechanism";
          else type = "unknown";

          return {
            id,
            type,
            color: getNodeColor(id, type),
            size: getNodeSize(id, type),
          };
        });

        // Set up SVG
        const container = document.getElementById("network");
        const width = container.clientWidth;
        const height = container.clientHeight;

        const svg = d3
          .select("#network")
          .append("svg")
          .attr("width", width)
          .attr("height", height);

        // Create tooltip
        const tooltip = d3
          .select("body")
          .append("div")
          .attr("class", "tooltip");

        // Set up force simulation
        const simulation = d3
          .forceSimulation(nodes)
          .force("link", d3.forceLink().id((d) => d.id).distance(100))
          .force("charge", d3.forceManyBody().strength(-300))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius((d) => d.size + 5));

        // Update visualization function
        function updateVisualization() {
          const threshold = +d3.select("#edgeThreshold").property("value");
          const showPositive = d3.select("#showPositive").property("checked");
          const showNegative = d3.select("#showNegative").property("checked");

          // Filter edges based on threshold and type
          const filteredEdges = edgeData.filter((d) => {
            const absCorr = Math.abs(d.partial_correlation);
            const isPositive = d.partial_correlation > 0;
            
            return (
              absCorr >= threshold &&
              ((isPositive && showPositive) || (!isPositive && showNegative))
            );
          });

          // Update links
          const links = svg.selectAll(".edge").data(filteredEdges);

          links.exit().remove();

          const newLinks = links
            .enter()
            .append("line")
            .attr("class", "edge")
            .merge(links)
            .attr("stroke", (d) => (d.partial_correlation > 0 ? "#27ae60" : "#e74c3c"))
            .attr("stroke-width", (d) => Math.abs(d.partial_correlation) * 8)
            .on("mouseover", function (event, d) {
              tooltip.transition().duration(200).style("opacity", 0.9);
              tooltip
                .html(
                  `<strong>${d.source} ‚Üí ${d.target}</strong><br/>
                   Correlation: ${d.partial_correlation.toFixed(3)}<br/>
                   Type: ${d.edge_type}`
                )
                .style("left", event.pageX + 10 + "px")
                .style("top", event.pageY - 28 + "px");
            })
            .on("mouseout", function () {
              tooltip.transition().duration(500).style("opacity", 0);
            });

          // Update simulation with new links
          simulation.force("link").links(filteredEdges);
          simulation.alpha(0.3).restart();

          // Update positions
          newLinks
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);
        }

        // Create nodes
        const nodeElements = svg
          .selectAll(".node")
          .data(nodes)
          .enter()
          .append("circle")
          .attr("class", "node")
          .attr("r", (d) => d.size)
          .attr("fill", (d) => d.color)
          .attr("stroke", "#fff")
          .attr("stroke-width", 2)
          .call(d3.drag()
            .on("start", (event, d) => {
              if (!event.active) simulation.alphaTarget(0.3).restart();
              d.fx = d.x;
              d.fy = d.y;
            })
            .on("drag", (event, d) => {
              d.fx = event.x;
              d.fy = event.y;
            })
            .on("end", (event, d) => {
              if (!event.active) simulation.alphaTarget(0);
              d.fx = null;
              d.fy = null;
            })
          )
          .on("mouseover", function (event, d) {
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip
              .html(
                `<strong>${d.id}</strong><br/>Type: ${d.type}<br/>Theory: ${nodeToTheory[d.id]?.theory || "Unknown"}`
              )
              .style("left", event.pageX + 10 + "px")
              .style("top", event.pageY - 28 + "px");
          })
          .on("mouseout", function () {
            tooltip.transition().duration(500).style("opacity", 0);
          });

        // Create labels
        const labels = svg
          .selectAll(".node-label")
          .data(nodes)
          .enter()
          .append("text")
          .attr("class", "node-label")
          .text((d) => d.id.replace(/_/g, " "))
          .style("font-size", (d) => (d.type === "outcome" ? "15px" : "13px"))
          .style("font-weight", (d) => (d.type === "outcome" ? "bold" : "400"));

        // Simulation tick
        simulation.on("tick", () => {
          svg.selectAll(".edge")
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);

          nodeElements
            .attr("cx", (d) => d.x)
            .attr("cy", (d) => d.y);

          labels
            .attr("x", (d) => d.x)
            .attr("y", (d) => d.y + 5);
        });

        // Initial visualization
        updateVisualization();

        // Store update function and labels for external use
        window.updateVisualization = updateVisualization;
        window.currentLabels = labels;
      }

      function saveSvg() {
        const svg = d3.select("#network svg").node();
        if (!svg) {
          alert("No visualization to save!");
          return;
        }

        const svgClone = svg.cloneNode(true);
        svgClone.setAttribute("width", svg.clientWidth || 800);
        svgClone.setAttribute("height", svg.clientHeight || 600);
        svgClone.setAttribute("xmlns", "http://www.w3.org/2000/svg");

        const style = document.createElement("style");
        style.textContent = `
          .node-label { font-size: 11px; font-weight: bold; text-anchor: middle; pointer-events: none; font-family: Arial, sans-serif; }
          .edge { stroke-opacity: 0.6; }
        `;
        svgClone.insertBefore(style, svgClone.firstChild);

        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(svgClone);

        const timestamp = new Date()
          .toISOString()
          .slice(0, 19)
          .replace(/:/g, "-");
        const filename = `network_${currentGroup}_${timestamp}.svg`;

        try {
          const blob = new Blob([svgString], { type: "image/svg+xml" });
          const url = URL.createObjectURL(blob);

          const link = document.createElement("a");
          link.href = url;
          link.download = filename;
          link.style.display = "none";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          URL.revokeObjectURL(url);

          document.getElementById("fileStatus").textContent = `‚úÖ ${filename} saved to Downloads folder`;
          document.getElementById("fileStatus").style.color = "#27ae60";
          
          setTimeout(() => {
            if (allData.length > 0) {
              document.getElementById("fileStatus").textContent = `‚úÖ Loaded ${allData.length} edges successfully`;
            }
          }, 3000);
        } catch (error) {
          console.error("Save failed:", error);
          alert("Save failed. Check browser console for errors.");
        }
      }

      // Initialize and set up event handlers
      async function init() {
        // File upload setup
        document.getElementById("uploadBtn").addEventListener("click", () => {
          document.getElementById("csvFile").click();
        });

        document.getElementById("csvFile").addEventListener("change", async function (event) {
          const file = event.target.files[0];
          if (file) {
            document.getElementById("fileStatus").textContent = "üì§ Loading uploaded file...";
            document.getElementById("fileStatus").style.color = "#3498db";
            
            const reader = new FileReader();
            reader.onload = async function (e) {
              const csvText = e.target.result;
              await loadData(csvText);
              await createNetwork();
            };
            reader.readAsText(file);
          }
        });

        document.getElementById("saveSvg").addEventListener("click", saveSvg);

        // Group selector handler
        d3.select("#groupSelector").on("change", async function () {
          currentGroup = this.value;
          await createNetwork();
        });

        // Other control handlers
        d3.select("#showLabels").on("change", function () {
          if (window.currentLabels) {
            window.currentLabels.style("display", this.checked ? "block" : "none");
          }
        });

        d3.select("#edgeThreshold").on("input", function () {
          d3.select("#thresholdValue").text(this.value);
          if (window.updateVisualization) {
            window.updateVisualization();
          }
        });

        d3.select("#showPositive").on("change", function () {
          if (window.updateVisualization) {
            window.updateVisualization();
          }
        });

        d3.select("#showNegative").on("change", function () {
          if (window.updateVisualization) {
            window.updateVisualization();
          }
        });

        // Initial threshold display
        d3.select("#thresholdValue").text(d3.select("#edgeThreshold").property("value"));

        // Try to load data initially
        await createNetwork();
      }

      // Handle window resize
      window.addEventListener("resize", function () {
        if (window.updateVisualization) {
          setTimeout(createNetwork, 100);
        }
      });

      // Start the application
      init();
    </script>
  </body>
</html>
